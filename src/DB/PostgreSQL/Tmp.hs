{-| Create temporary postgresql databases.

The main usecase for this are tests where you donâ€™t want to assume that a certain database exists.
-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
module DB.PostgreSQL.Tmp (
  withTmpDB,
  withTmpDB',
  newRole,
  dropRole,

  newDB,
  dropDB,

  defaultDBConn,
  defaultDBConnPool,

  DBInfo(..)
) where

import Protolude

import Control.Exception
import Data.Coerce
import Data.Pool

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.Types

defaultDBConn :: IO Connection
defaultDBConn = connect defaultConnectInfo

defaultDBConnPool :: IO (Pool Connection)
defaultDBConnPool =
  defaultDBConn >>= \conn ->
    createPool (pure conn) close 5 0.5 1

-- | The data necessary to connect to the temporary database
data DBInfo =
  DBInfo {dbName :: Text
         ,roleName :: Text} deriving (Show,Read,Eq,Ord)

-- | Convenience wrapper for 'withTmpDB'' using 'defaultDB'
withTmpDB :: (DBInfo -> IO a) -> IO a
withTmpDB = withTmpDB' $ postgreSQLConnectionString defaultConnectInfo

-- | Create a temporary database and a temporary role that the
-- callback can operate on. After the action has finished the database
-- and the role are destroyed.
--
-- This function assumes that the connection string points to a
-- database containing the tables called @pg_roles@ and @pg_database@
-- and that the user has the @CREATEDB@ and @CREATEROLE@ privileges.
withTmpDB' :: ByteString -> (DBInfo -> IO a) -> IO a
withTmpDB' conStr f =
  bracket (connectPostgreSQL conStr) close $
    \conn ->
       bracket (newRole conn) (dropRole conn) $ \role -> do
       bracket (newDB conn role) (dropDB conn) $ \db -> do
         f (DBInfo {dbName = db, roleName = role})

-- | Create a new role that does not already exist and return its name.
--
-- The new role does not have a password and has the @CREATEDB@
-- privilege. The database that the connection points to is assumed to
-- contain a table called @pg_roles@ with a @rolname@ column.
newRole :: Connection -> IO Text
newRole conn =
  do (roles :: [Only Text]) <- query_ conn "SELECT rolname FROM pg_roles"
     let newName = freshName "tmp" (coerce roles)
     _ <- execute conn "CREATE USER ? WITH CREATEDB" (Only (Identifier newName))
     pure newName

-- | Drop the role.
dropRole :: Connection -> Text -> IO Int64
dropRole conn name = execute conn "DROP ROLE ?" (Only (Identifier name))

-- | Create a new database that is owned by the user.
newDB :: Connection -> Text -> IO Text
newDB conn role =
  do (dbNames :: [Only Text]) <- query_ conn "SELECT datname FROM pg_database"
     let newName = freshName "tmp" (coerce dbNames)
     _ <- execute conn "CREATE DATABASE ? OWNER ?" (Identifier newName,Identifier role)
     pure newName

-- | Drop the database.
dropDB :: Connection -> Text -> IO Int64
dropDB conn name =
  execute conn "DROP DATABASE ?" (Only (Identifier name))

-- | Create a fresh name that is not in the list of already existing names.
--
-- The fresh name is generated by appending a number to the supplied
-- template.
freshName :: Text -> [Text] -> Text
freshName template existingNames = loop 0
-- We could use a Set here to speed up the lookup, however the
-- construction of that Set is linear as well so it would only pay off
-- if at least one of the lookups fails.
  where loop :: Int -> Text
        loop i =
          if (template <> show i) `elem` existingNames
             then loop (i + 1)
             else (template <> show i)
